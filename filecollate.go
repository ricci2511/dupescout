package filecollate

import (
	"errors"
	"fmt"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"

	"github.com/puzpuzpuz/xsync/v3"
	"golang.org/x/sync/errgroup"
)

type pair struct {
	key  string // depends on the KeyGeneratorFunc
	path string
}

type filecollate struct {
	g           *errgroup.Group  // "wait group" to limit the num of concurrent search workers
	pairs       chan *pair       // channel to send pairs to, which are processed and sent to the caller
	shutdown    chan os.Signal   // channel to receive shutdown signals on
	generatorFn KeyGeneratorFunc // function that generates a key for a given path to identify files to group
	filters     Filters          // filters to apply when searching for files to group
}

func newFilecollate(c Cfg) *filecollate {
	g := new(errgroup.Group)
	g.SetLimit(c.Workers)

	return &filecollate{
		g:           g,
		pairs:       make(chan *pair, c.Workers),
		shutdown:    make(chan os.Signal, 1),
		generatorFn: c.KeyGenerator,
		filters:     c.Filters,
	}
}

// Starts the search for files to group which can be customized by the provided Cfg struct.
func run(c Cfg, consumerFunc func(fc *filecollate)) error {
	c.defaults()
	fc := newFilecollate(c)

	go consumerFunc(fc)
	go gracefulShutdown(fc.shutdown)

	for _, path := range c.Paths {
		p := path
		fc.g.Go(func() error {
			return fc.search(p)
		})
	}

	err := fc.g.Wait()
	close(fc.pairs) // Trigger pair consumer to process the results.
	return err
}

// Runs the search and returns a map of keys and paths grouped by the generated key.
func GetResults(c Cfg) (map[string][]string, error) {
	collectorChan := make(chan map[string][]string, 1)
	err := run(c, func(fc *filecollate) {
		consumePairsMap(fc.pairs, collectorChan)
	})
	return <-collectorChan, err
}

// Runs the search and returns 2D slice of paths, each high-level slice representing a group.
func GetResultsSlice(c Cfg) ([][]string, error) {
	collectorChan := make(chan [][]string, 1)
	err := run(c, func(fc *filecollate) {
		consumePairsSlice(fc.pairs, collectorChan)
	})
	return <-collectorChan, err
}

// Directly streams produced pairs (key, path) to the provided channel. This is useful if you want to
// process the key-path pairs yourself.
func StreamPairs(c Cfg, collectorChan chan *pair) error {
	return run(c, func(fc *filecollate) {
		for p := range fc.pairs {
			collectorChan <- p
		}
	})
}

// Processes the produced pairs and sends the results to the provided channel.
// Depending on the stream bool, results are either sent in chunks or all at once.
func consumePairsSlice(pairs chan *pair, collector chan [][]string) {
	defer close(collector)

	var groupedPaths [][]string

	// key -> index of the slice containing the grouped paths + the first path for the key
	type data struct {
		firstPath string
		idx       int
	}
	m := xsync.NewMapOf[string, data]()

	for p := range pairs {
		// -1 is used as a flag to indicate that we have found the first iteration of the key
		stored, loaded := m.LoadOrStore(p.key, data{p.path, -1})
		if !loaded {
			continue
		}

		idx := stored.idx

		// First match for the key, create a new slice and update the map
		if idx == -1 {
			groupedPaths = append(groupedPaths, []string{stored.firstPath, p.path})
			m.Store(p.key, data{"", len(groupedPaths) - 1}) // Update idx (first path doesn't matter anymore)
			continue
		}

		groupedPaths[idx] = append(groupedPaths[idx], p.path)
	}

	collector <- groupedPaths
}

// Consumes the pairs and sends the results to the provided channel as a map.
// Blocks until all pairs have been processed.
func consumePairsMap(pairs chan *pair, collector chan map[string][]string) {
	defer close(collector)

	m := xsync.NewMapOf[string, []string]()

	for p := range pairs {
		paths, loaded := m.LoadOrStore(p.key, []string{p.path})
		if loaded {
			m.Store(p.key, append(paths, p.path))
		}
	}

	retMap := make(map[string][]string)
	m.Range(func(key string, paths []string) bool {
		// If there is only one path for a key, don't include it in the results
		if len(paths) <= 1 {
			return true
		}
		retMap[key] = paths
		return true
	})

	collector <- retMap
}

// Produces a pair with the key which is generated by `fc.generatorFn` and the path
// which is then sent to the pairs channel.
func (fc *filecollate) producePair(path string) error {
	if fc.shuttingDown() {
		return nil // Stop pair production if shutdown is in progress.
	}

	key, err := fc.generatorFn(path)
	if err != nil {
		if errors.Is(err, ErrSkipFile) {
			return nil // Don't collect ErrSkipFile errors
		}
		return err
	}

	if key == "" {
		return fmt.Errorf("\nkey generator returned an empty key for path: %s", path)
	}

	fc.pairs <- &pair{key, path}
	return nil
}

// Walks the tree of the provided dir and triggers the production of pairs for each valid file.
func (fc *filecollate) search(dir string) error {
	return filepath.WalkDir(dir, func(path string, de os.DirEntry, err error) error {
		if fc.shuttingDown() {
			return nil
		}

		if err != nil {
			return err
		}

		if de.IsDir() && fc.filters.skipDir(path) {
			return filepath.SkipDir
		}

		if de.Type().IsRegular() && !fc.filters.skipFile(path) {
			fi, err := de.Info()
			if err != nil || fi.Size() == 0 {
				return nil
			}

			fc.g.Go(func() error {
				return fc.producePair(path)
			})
		}

		return nil
	})
}

// Helper to check if a shutdown signal has been received.
func (fc *filecollate) shuttingDown() bool {
	select {
	case <-fc.shutdown:
		return true
	default:
		return false
	}
}

// Sets up a signal handler worker for graceful shutdown.
func gracefulShutdown(shutdown chan os.Signal) {
	signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)
	<-shutdown
	log.Println("\nReceived signal, shutting down after current workers are done...")
	close(shutdown)
}
